{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"typera - Build type-safe web backends","text":"<p>Typera helps you build backends in a type-safe manner by leveraging io-ts and some TypeScript type inference magic. It works with both Express and Koa.</p> <p>When you see an <code>any</code>, you cannot really be sure anymore. When building web backends, there are quite a few <code>any</code>s involved:</p> <ul> <li> <p>You get a request in. Captured route params, query params from the URL and   request body are all <code>any</code>.</p> </li> <li> <p>When generating a response, the response body's type is <code>any</code>.</p> </li> <li> <p>When middleware is involved, there's no type-level visibility to which   transforms the middleware apply to the request, or which responses it might   return.</p> </li> <li> <p>The response status is a <code>number</code>. It's not as bad as <code>any</code>, but your routes   always return responses from a known set of possible status code / body   combinations.</p> </li> </ul> <p>By default, the compiler cannot help you with any (pun intended) of this. But with typera, you're safe!</p> <p>Features of typera:</p> <ul> <li> <p>A purer approach to building your apps: Each route handler is an async   function that takes a request and returns a response. Mutable <code>req</code> or <code>res</code>   objects? Never again!</p> </li> <li> <p>Automatically parses request inputs like route params, query params, headers   and request body into typed values.</p> </li> <li> <p>Infer the types of responses (status code, body, headers), allow type checking   them according to your expectations.</p> </li> <li> <p>Middleware are fully typed. This means that you no longer have to guess what's   available in <code>req</code>, or whether a middleware short-circuits and returns a   response. Instead, everything is type checked!</p> </li> <li> <p>It's straightforward to start adding fully typed routes to an existing Express   or Koa app. Old routes can be migrated gradually.</p> </li> <li> <p>Built-in support for automatically generating an OpenAPI definition from your   app with typera-openapi.</p> </li> </ul> <p>Typera is a really thin layer on top of Express or Koa. Most of its code is TypeScript typings, and the actual runtime stuff is minimal.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Typera requires TypeScript 4.1 or newer and Node 12 or newer.</p> <p>Install for Express:</p> <pre><code>yarn add typera-express\n# or\nnpm install typera-express\n</code></pre> <p>Install for Koa:</p> <pre><code>yarn add typera-koa\n# or\nnpm install typera-koa\n</code></pre> <p>Example:</p> <pre><code>// Change 'typera-express' to 'typera-koa' if you're using Koa\nimport { Parser, Response, Route, URL, route } from 'typera-express'\nimport * as t from 'io-ts'\n\ninterface User {\nid: number\nname: string\nage: number\n}\n\n// Decodes an object { name: string, age: number }\nconst userBody = t.type({ name: t.string, age: t.number })\n\nconst updateUser: Route&lt;\n// Optional annotation of possible response types\nResponse.Ok&lt;User&gt; | Response.NotFound | Response.BadRequest&lt;string&gt;\n&gt; = route\n.put('/user/:id(int)') // Capture id from the path\n.use(Parser.body(userBody)) // Use the userBody decoder for the request body\n.handler(async (request) =&gt; {\n// This imaginary function takes the user id and data, and updates the\n// user in the database. If the user does not exist, it returns null.\nconst user = await updateUserInDatabase(\n// The stuff inside `request` is fully typed!\nrequest.routeParams.id,\nrequest.body\n)\n\nif (user === null) {\nreturn Response.notFound()\n}\n\nreturn Response.ok({\nid: user.id,\nname: user.name,\nage: user.age,\n})\n})\n</code></pre> <p>Got interested? Head to the tutorial.</p>"},{"location":"apiref/","title":"API Reference","text":""},{"location":"apiref/#imports","title":"Imports","text":"<p>typera exposes its contents in various modules, e.g. <code>Response</code>, <code>Middleware</code>, <code>Parser</code>, etc. In the examples below, they are imported from the top-level module like this:</p> <pre><code>import { Response, Middleware, Parser } from 'typera-express'\n// or\nimport { Response, Middleware, Parser } from 'typera-koa'\n</code></pre> <p>You can also import from the individual modules:</p> <pre><code>import * as Response from 'typera-express/response'\nimport * as Middleware from 'typera-express/middleware'\nimport * as Parser from 'typera-express/parser'\n// or\nimport * as Response from 'typera-koa/response'\nimport * as Middleware from 'typera-koa/middleware'\nimport * as Parser from 'typera-koa/parser'\n</code></pre> <p>And of course, you can also import individual items when importing directly from the modules:</p> <pre><code>import { BadRequest } from 'typera-express/response'\n// or\nimport { BadRequest } from 'typera-koa/response'\n</code></pre>"},{"location":"apiref/#responses","title":"Responses","text":"<p>All response related types and functions live in the <code>Response</code> namespace.</p> <pre><code>import { Response } from 'typera-express'\n// or\nimport { Response } from 'typera-koa'\n</code></pre> <p>The generic <code>Response</code> type looks like this:</p> <pre><code>type OptionalHeaders = { [key: string]: string } | undefined\n\ntype Response&lt;Status, Body, Headers extends OptionalHeaders&gt; = {\nstatus: Status\nbody: Body\nheaders: Headers\n}\n</code></pre> <p>There is a separate type and a function to construct a response of that type for each valid HTTP status code.</p> <p>For example, the response type for a 200 OK is:</p> <pre><code>type Ok&lt;\nBody = undefined,\nHeaders extends OptionalHeaders = undefined,\n&gt; = Response&lt;200, Body, Headers&gt;\n</code></pre> <p>The function to construct a 200 OK response has the following overloaded signatures:</p> <pre><code>function ok(): Ok\nfunction ok&lt;Body&gt;(body: Body): Ok&lt;Body&gt;\nfunction ok&lt;Body, Headers extends OptionalHeaders&gt;(\nbody: Body,\nheaders: Headers\n): Ok&lt;Body, Headers&gt;\n</code></pre> <p>All response types have the <code>Body</code> and <code>Headers</code> type parameters. With other than redirect responses, both default to <code>undefined</code>. All response constructor functions have the same 3 signatures.</p>"},{"location":"apiref/#common-responses","title":"Common responses","text":"<p>Here's a list of most common responses:</p> HTTP Type Constructor function 200 OK <code>Ok</code> <code>ok</code> 201 Created <code>Created</code> <code>created</code> 204 No Content <code>NoContent</code> <code>noContent</code> 301 Moved Permanently <code>MovedPermanently</code> <code>movedPermanently</code> 302 Found <code>Found</code> <code>found</code> 304 Not Modified <code>NotModified</code> <code>notModified</code> 400 Bad Request <code>BadRequest</code> <code>badRequest</code> 401 Unauthorized <code>Unauthorized</code> <code>unauthorized</code> 403 Forbidden <code>Forbidden</code> <code>forbidden</code> 404 Not Found <code>NotFound</code> <code>notFound</code> 405 Method Not Allowed <code>MethodNotAllowed</code> <code>methodNotAllowed</code> <p>For the full list of supported responses, see response.ts.</p>"},{"location":"apiref/#redirects","title":"Redirects","text":"<p>Redirecting the client to another URL is a common thing to do and requires setting a header. To create a redirect response, use the <code>redirect(status, location)</code> helper:</p> <pre><code>const myHandler: Route&lt;Response.MovedPermanently&gt; = route\n.get('/foo')\n.handler(async (request) =&gt; {\nreturn Response.redirect(301, '/bar')\n})\n</code></pre> <p>This generates a response with a string body and the <code>Location</code> header set:</p> <pre><code>HTTP/1.1 301 Moved Permanently\nLocation: /bar\n\nMoved premanently. Redirecting to /bar\n</code></pre> <p>For simplicity, the redirecting responses listed below have the default body type of <code>string</code> and the default headers type of <code>{ location: string }</code>:</p> HTTP Type Constructor function 301 Moved Permanently <code>MovedPermanently</code> <code>redirect(301, location)</code> 302 Found <code>Found</code> <code>redirect(302, location)</code> 303 See Other <code>SeeOther</code> <code>redirect(303, location)</code> 307 Temporary Redirect <code>TemporaryRedirect</code> <code>redirect(307, location)</code> 308 Permanent Redirect <code>PermanentRedirect</code> <code>redirect(308, location)</code> <p>Use the \"normal\" constructor functions (<code>movedPermanently()</code>, <code>found()</code>, ...) if you want full control over the body and headers.</p>"},{"location":"apiref/#redirect","title":"<code>redirect</code>","text":"<p>Signature: <code>Response.redirect(status, location)</code></p> <p>Creates a response that redirects to the given location. The response body will be a textual explanation of the redirect.</p>"},{"location":"apiref/#streaming-responses","title":"Streaming responses","text":"<p>Use the <code>Response.StreamingBody</code> body type and the <code>Response.streamingBody()</code> function to create streaming responses. The function takes a callback that receives a writable stream as a parameter:</p> <pre><code>const streamingHandler: Route&lt;Response.Ok&lt;Response.StreamingBody&gt;&gt; = route\n.get('/document.pdf')\n.handler(async (request) =&gt; {\nreturn Response.ok(\nResponse.streamingBody((outputStream) =&gt; {\n// Assuming that the generatePDF function generates a\n// PDF document to the given writable stream\ngeneratePDF(outputStream)\n})\n)\n})\n</code></pre>"},{"location":"apiref/#response-content-type","title":"Response content type","text":"<p>You can set the response content type by returning a <code>Content-Type</code> header with the response, e.g.:</p> <pre><code>return Response.ok(csvData, { 'Content-Type': 'text/csv' })\n</code></pre> <p>If you don't set the <code>Content-Type</code> header, typera defaults to the following:</p> <ul> <li><code>application/json</code> for object and array responses. The value is encoded as   JSON.</li> <li><code>application/octet-stream</code> for <code>Buffer</code> and   streaming responses.</li> <li><code>text/plain</code> for values of primitive types (string, number, boolean). The   value is converted to a string by calling <code>value.toString()</code>.</li> <li>No content type and an empty response body for <code>null</code> and <code>undefined</code>.</li> </ul>"},{"location":"apiref/#middleware","title":"Middleware","text":"<pre><code>import * as Either from 'fp-ts/lib/Either'\nimport { RequestBase, Middleware, ChainedMiddleware } from 'typera-koa'\n// or\nimport { RequestBase, Middleware, ChainedMiddleware } from 'typera-express'\n</code></pre> <p>Middleware are asynchronous functions that take a typera request object as a parameter, and produce either a <code>Response</code> or an object.</p> <p>If a middleware function produces a <code>Response</code>, then the request handling is stopped and that response is sent to the client. If it produces an object, that object is merged to the typera request object which is passed forward to the next middleware and eventually to the route handler.</p> <p>A middleware function can also add a finalizer function to be called after the request handler has finished. This is useful if the middleware allocates some resources that need to be released afterwards (e.g. release a database connection, delete a temporary file, etc.)</p> <p>For example, here's a middleware that authenticates a user and adds user info to the typera request object:</p> <pre><code>const authenticateUser: Middleware.Middleware&lt;\n// This is the object that's merged to request on success\n{ user: User },\n// This is the response that is be returned by the middleware on failure\nResponse.Unauthorized&lt;string&gt;\n&gt; = async () =&gt; {\nconst user = await authenticateUser() // Gets a user somehow and returns null if unauthenticated\nif (!user) {\nreturn Middleware.stop(Response.unauthorized('Login first'))\n}\nreturn Middleware.next({ user })\n}\n</code></pre> <p>Another example of a middleware that adds a database client to the typera request object. It never returns a response, so the response type is <code>never</code>.</p> <pre><code>import * as pg from 'pg'\n\nconst pool = new pg.Pool()\n\nconst db: Middleware.Middleware&lt;\n{ connection: pg.ClientBase },\nnever\n&gt; = async () =&gt; {\nconst connection = await pool.connect()\nreturn Middleware.next({ connection }, () =&gt; connection.release())\n}\n</code></pre> <p>If you write a middleware that adds nothing to the typera request object, its result type should be <code>unknown</code>:</p> <pre><code>const checkOrigin: Middleware.Middleware&lt;\nunknown,\nResponse.BadRequest&lt;string&gt;\n&gt; = async (request) =&gt; {\n// In typera-express, request.req is the Express request\nif (request.req.get('origin') !== 'example.com') {\nreturn Middleware.stop(Response.badRequest('Invalid origin'))\n}\nreturn Middleware.next()\n}\n</code></pre>"},{"location":"apiref/#next","title":"<code>next</code>","text":"<p>Signatures:</p> <ul> <li><code>Middleware.next()</code></li> <li><code>Middleware.next(value)</code></li> <li><code>Middleware.next(value, finalizer)</code></li> </ul> <p>Construct a value to be merged with the typera request object, and optionally add a finalizer to be run when the request processing has finished.</p> <p>If <code>Middleware.next()</code> is called with no arguments, nothing is added to the typera request object.</p> <p>The finalizer, if given, is called with no arguments. It can be an async function (can return a <code>Promise</code>).</p> <p>If you want to run a finalizer but not add anything to the request, you can pass <code>{}</code> or <code>undefined</code> as the value.</p>"},{"location":"apiref/#stop","title":"<code>stop</code>","text":"<p>Signature: <code>Middleware.stop(response)</code></p> <p>Stop processing the request and return <code>response</code> to the client. Other middleware or the route handler will not be run. If other middleware have already run before this one, their finalizers are run.</p>"},{"location":"apiref/#chainedmiddleware","title":"<code>ChainedMiddleware</code>","text":"<p>If you need to use the result of some previous middleware, use <code>ChainedMiddleware</code>. It's like <code>Middleware</code> but takes as first type parameter the type that previous middleware should produce. This middleware writes audit entries to database, so it requires a database connection from the <code>db</code> middleware above:</p> <pre><code>const audit: Middleware.ChainedMiddleware&lt;\n{ connection: pg.ClientBase },\nunknown,\nnever\n&gt; = async (request) =&gt; {\nawait writeAuditLog(request.connection)\nreturn Middleware.next()\n}\n</code></pre> <p>Now, the <code>audit</code> middleware can only be used if the <code>db</code> middleware comes before it and adds <code>connection</code> to the request object.</p> <pre><code>const myRoute = route.use(db).use(audit)\n</code></pre>"},{"location":"apiref/#request-parsers","title":"Request parsers","text":"<p>Request parsers are built-in middleware that let you validate parts of the request. All request parser related types and functions live in the <code>Parser</code> namespace.</p> <pre><code>import * as t from 'io-ts'\nimport { Parser } from 'typera-express'\n// or\nimport { Parser } from 'typera-koa'\n</code></pre> <p>typera provides functions to build request parser middleware for query string and request body. These functions take an io-ts codec (<code>t.Type</code>) and return a middleware that validates the corresponding part of the request using the given codec. If the validation fails, they produce an error response with appropriate status code and error message in the body.</p>"},{"location":"apiref/#query","title":"<code>query</code>","text":"<p>Signature: <code>Parser.query(codec)</code></p> <p>Validate the query string according to the given io-ts codec. Respond with <code>400 Bad Request</code> if the validation fails. The result will be available as <code>request.query</code> in the route handler.</p> <p>The input for this parser will be the query string parsed as <code>Record&lt;string, string&gt;</code>, i.e. all parameter values will be strings. If you want to convert them to other types, you probably find the <code>FromString</code> codecs from io-ts-types useful (e.g. <code>IntFromString</code>, <code>BooleanFromString</code>, etc.)</p>"},{"location":"apiref/#body","title":"<code>body</code>","text":"<p>Signature: <code>Parser.body(codec)</code></p> <p>Validate the request body according to the given io-ts codec. Respond with <code>400 Bad Request</code> if the validation fails. Ther result will be available as <code>request.body</code> in the route handler.</p> <p>The input for this parser will be the request body, parsed with the body parser of your choice. With Express you probably want to use body-parser, and with Koa the most common choice is koa-bodyparser. Note that these are native Express or Koa middleware, so you must attach them directly to the Express or Koa app rather than use them as typera middleware.</p> <p>Note</p> <p>You must use a Express or Koa body parsing middleware for <code>Parser.body</code> to work.</p>"},{"location":"apiref/#headers","title":"<code>headers</code>","text":"<p>Signature: <code>Parser.headers(codec)</code></p> <p>Validate the request headers according to the given io-ts codec. Respond with <code>400 Bad Request</code> if the validation fails. The result will be available as <code>request.headers</code> in the route handler.</p> <p>Header matching is case-insensitive, so using e.g. <code>X-API-KEY</code>, <code>x-api-key</code> and <code>X-Api-Key</code> in the codec will all read the same header. However, the parse result will of course be case sensitive. That is, the field in <code>request.headers</code> will have the name you specify in the io-ts codec you pass to <code>Parser.headers</code>, with case preserved.</p> <p>The input for this parser will be the headers parsed as <code>Record&lt;string, string&gt;</code>, i.e. all header values will be strings. If you want to convert them to other types, you probably find the <code>FromString</code> codecs from io-ts-types useful (e.g. <code>IntFromString</code>, <code>BooleanFromString</code>, etc.)</p>"},{"location":"apiref/#cookies","title":"<code>cookies</code>","text":"<p>Signature: <code>Parser.cookies(codec)</code></p> <p>Validate the request cookies according to the given io-ts codec. Respond with <code>400 Bad Request</code> if the validation fails. The result will be available as <code>request.cookies</code> in the route handler.</p> <p>The input for this parser will be the cookies parsed as <code>Record&lt;string, string&gt;</code>, i.e. all cookie values will be strings. If you want to convert them to other types, you probably find the <code>FromString</code> codecs from io-ts-types useful (e.g. <code>IntFromString</code>, <code>BooleanFromString</code>, etc.)</p>"},{"location":"apiref/#customizing-the-error-response","title":"Customizing the error response","text":"<p>Each of the above functions also have a <code>P</code> flavor that allows the user to override error handling. In addition to an io-ts codec, these functions take an error handler function that receives an io-ts validation error and produces an error response:</p> <pre><code>type ErrorHandler&lt;ErrorResponse extends Response.Response&lt;number, any, any&gt;&gt; = (\nerrors: t.Errors\n) =&gt; ErrorResponse\n\nfunction queryP&lt;\nCodec extends t.Type&lt;any&gt;,\nErrorResponse extends Response.Response&lt;number, any, any&gt;,\n&gt;(\ncodec: Codec,\nerrorHandler: ErrorHandler&lt;ErrorResponse&gt;\n): Middleware&lt;{ query: t.TypeOf&lt;Codec&gt; }, ErrorResponse&gt;\n\nfunction bodyP&lt;\nCodec extends t.Type&lt;any&gt;,\nErrorResponse extends Response.Response&lt;number, any, any&gt;,\n&gt;(\ncodec: Codec,\nerrorHandler: ErrorHandler&lt;ErrorResponse&gt;\n): Middleware&lt;{ body: t.TypeOf&lt;Codec&gt; }, ErrorResponse&gt;\n\nfunction headersP&lt;\nCodec extends t.Type&lt;any&gt;,\nErrorResponse extends Response.Response&lt;number, any, any&gt;,\n&gt;(\ncodec: Codec,\nerrorHandler: ErrorHandler&lt;ErrorResponse&gt;\n): Middleware&lt;{ headers: t.TypeOf&lt;Codec&gt; }, ErrorResponse&gt;\n\nfunction cookiesP&lt;\nCodec extends t.Type&lt;any&gt;,\nErrorResponse extends Response.Response&lt;number, any, any&gt;,\n&gt;(\ncodec: Codec,\nerrorHandler: ErrorHandler&lt;ErrorResponse&gt;\n): Middleware&lt;{ cookies: t.TypeOf&lt;Codec&gt; }, ErrorResponse&gt;\n</code></pre> <p>If you want to abstract your custom error handling to reuse it in multiple routes, you can create your own parser functions like this:</p> <pre><code>import * as t from 'io-ts'\n\nfunction errorToString(err: t.Errors): string {\n// Turn err to string the way you like\n}\n\nconst myQuery = &lt;T,&gt;(\ncodec: t.Type&lt;T&gt;\n): Middleware&lt;{ query: T }, Response.BadRequest&lt;string&gt;&gt; =&gt;\nParser.queryP(codec, (errors) =&gt; Response.badRequest(errorToString(errors)))\n\n// You can alse return a different response than 400 Bad Request\nconst myBody = &lt;T,&gt;(\ncodec: t.Type&lt;T&gt;\n): Middleware&lt;{ body: T }, Response.Conflict&lt;string&gt;&gt; =&gt;\nParser.bodyP(codec, (errors) =&gt; Response.conflict(errorToString(errors)))\n\n// etc...\n</code></pre>"},{"location":"apiref/#using-express-middleware","title":"Using express middleware","text":"<p>This is an experimental feature, and is currently available only for <code>typera-express</code>. It can change without a corresponding semver bump.</p> <p>Express middleware is inherently incompatible with typera middleware, because typera runs its middlewares independently of the Express middleware. This makes it possible to pass typed data to the next middleware and the route handler.</p> <p>However, lots of useful Express middleware already exists out there. <code>typera-express</code> has a function that helps you wrap existing Express middleware in a way that it works (mostly) like typera middleware does:</p>"},{"location":"apiref/#wrapnative","title":"<code>wrapNative</code>","text":"<p>Signatures:</p> <ul> <li><code>Middleware.wrapNative(expressMiddleware)</code></li> <li><code>Middleware.wrapNative(expressMiddleware, mapResult)</code></li> </ul> <p>Given Express middleware function <code>expressMiddleware</code>, return the corresponding typera middleware.</p> <p>If the <code>mapResult</code> function is given, its called after the middleware has run, and its return value is merged to the typera request object. Use this function to take any data the wrapped middleware produces and make it consumable by other typera middleware or the route handler function.</p> <p>The wrapped Express middleware may either pass the control to the next middleware (or route handler) in the chain by calling <code>next()</code>, the third parameter of the middleware function, or send the response and end the middleware chain. Some middleware use various tricks to hook to the point where the response is eventually sent, to e.g. log info about it. <code>wrapNative</code> tries to make all of this possible, but there might be corner cases which don't work yet.</p>"},{"location":"apiref/#routes","title":"Routes","text":"<pre><code>import { Route, URL, applyMiddleware, route } from 'typera-express'\n// or\nimport { Route, URL, applyMiddleware, route } from 'typera-koa'\n</code></pre>"},{"location":"apiref/#route","title":"<code>route</code>","text":"<p>A route matches a request based on HTTP method and path, and defines a function that serves a response for the matched request.</p> <p>Routes are created using the <code>route.[method](...)</code> or <code>route(method, ...)</code>, where method is one of <code>get</code>, <code>post</code>, <code>put</code>, <code>delete</code>, <code>head</code>, <code>options</code>, <code>patch</code> or <code>all</code>:</p> <pre><code>route\n.get(path)\n.use(middleware1, middleware2 /*, ... */)\n.handler(async (request) =&gt; {\n// ...\nreturn Response.ok()\n})\n</code></pre> <p>The special method <code>all</code> matches every HTTP method.</p> <p>The <code>route</code> functions take a path pattern as an argument. The path pattern can contain route parameter captures. The path if the incoming HTTP request is matched against the path pattern to see whether this route is responsible for serving the response for the HTTP request.</p> <p>They return an object with <code>.use()</code> and <code>.handler()</code> methods.</p> <p>The <code>.use()</code> method takes one or more middleware functions which are used to process the incoming request and create the typera request object (<code>request</code>). You can call <code>.use()</code> many times. The result of middleware in previous calls will be available in the typera request object passed to the next middleware. See <code>ChainedMiddleware</code> above on how to use the previous middleware results in the next middleware.</p> <p>The <code>.handler()</code> method takes a request handler, which is an async function that receives the typera request object returns a response.</p> <p>The typera request object is created by merging the route parameters and the result objects of middleware functions given to <code>route</code> or applied before. It also always extends the request base:</p> <pre><code>// typera-express\nexport type RequestBase = {\nreq: express.Request\nres: express.Response\n}\n\n// typera-koa\nexport type RequestBase = {\nctx: koa.Context\n}\n</code></pre> <p>In other words, in <code>typera-express</code> the Express req/res are always available as <code>request.req</code> and <code>request.res</code>, and in <code>typera-koa</code> the Koa context is always available as <code>request.ctx</code>.</p> <p>The type of <code>request</code> is inferred by typera, so there's no need for the user to give it an explicit type, while at the same time the TypeScript compiler checks that the properties of <code>request</code> are used correctly in the request handler.</p> <p><code>route</code> infers the response type by combining the error response types of all middleware functions, and the response types of the request handler. To get maximum type safety, you should explicitly declare the return type of <code>route</code> in your code. This makes sure that the possible responses of a route don't change unexpectedly because of changes in the code, and documents all the possible responses from a single route:</p> <pre><code>const listHandler: Route&lt;Response.Ok&lt;User&gt; | Response.BadRequest&lt;string&gt;&gt; =\nroute\n.get(/* ... */)\n.use(/* ... */)\n.handler(async (request) =&gt; {\n// ...\n})\n</code></pre> <p>We avoid giving the accurate type of the various <code>route</code> functions here, because they're quite complex due to the type inference of <code>request</code> and response types. Interested readers can refer to the code: common, express, koa,</p>"},{"location":"apiref/#routeuse","title":"<code>route.use</code>","text":""},{"location":"apiref/#applymiddleware","title":"<code>applyMiddleware</code>","text":"<p>Signatures:</p> <ul> <li><code>route.use(...middlewares)</code></li> <li><code>applyMiddleware(...middlewares)</code></li> </ul> <p>If you need to apply the same middleware to many routes, you can create your own version of <code>route</code> by calling either <code>route.use()</code> or <code>applyMiddleware()</code> with the middleware that are common to all of the routes:</p> <pre><code>// db and auth are middleware functions\nconst myRoute = route.use(db, auth)\n// or\nconst myRoute = route.use(db).use(auth)\n// or\nconst myRoute = applyMiddleware(db, auth)\n\nconst listHandler: Route&lt;...&gt; = myRoute.get(...)\nconst updateHandler: Route&lt;...&gt; = myRoute.put(...)\n</code></pre> <p>The value returned by <code>route.use()</code> and <code>applyMiddleware()</code> works exactly the same as <code>route</code> i.e. it has the <code>.get()</code>, <code>.post()</code> etc. methods and can be called directly.</p>"},{"location":"apiref/#route-parameter-capturing","title":"Route parameter capturing","text":"<p>Path patterns make it possible to extract some parts of the HTTP request path for use in the route handler.</p> <p>For example, with the following path:</p> <pre><code>route.get('/user/:id(int)').handler(async (request) =&gt; { ... })\n</code></pre> <p>In the route handler function, <code>req.routeParams.id</code> will contain the integer that was given after <code>/user/</code>, like this:</p> Path <code>req</code> <code>/user/5</code> <code>{ routeParams: { id: 5 }}</code> <code>/user/528472</code> <code>{ routeParams: { id: 528472 }}</code> <code>/user/foo</code> Route is not matched <code>/user/5/</code> Route is not matched <code>/user/</code> Route is not matched <p>Route parameters have the syntax <code>:name</code> or <code>:name(conv)</code>, where the optional <code>(conv)</code> specifies a conversion to be applied to the parameter. Without a conversion, the parameter is captured as a string.</p> <p>Parameter names should only contain the <code>a-z</code>, <code>A-Z</code> and <code>_</code> characters. They can be separated with <code>-</code> and <code>.</code>, so these are valid path patterns:</p> <ul> <li><code>/flights/:from-:to</code></li> <li><code>/plantae/:genus.:species</code></li> </ul> <p>One built-in conversion is available: <code>(int)</code> converts the parameter to a (non-negative) integer, or fails to match if something else than an integer is supplied.</p>"},{"location":"apiref/#useparamconversions","title":"<code>useParamConversions</code>","text":"<p>Signature: <code>route.useParamConversions({ ...convs })</code></p> <p><code>import * as Option from 'fp-ts/lib/Option</code></p> <p>You can register your own conversions by calling <code>useParamConversions</code>. It has one argument, an object of <code>{ name: conversion }</code>, where <code>name</code> specifies the name of the conversion and <code>conversion</code> is a function <code>(value: string) =&gt; Option.Option&lt;T&gt;</code>. If the function returns a <code>some</code>, the value will be available under the <code>name</code> key in <code>request.routeParams</code>. If it returns a <code>none</code>, the route will return a <code>404 Not Found</code> response.</p> <p>The value returned by <code>route.useParamConversions()</code>works exactly the same as <code>route</code> i.e. it has the <code>.get()</code>, <code>.post()</code> etc. methods and can be called directly.</p> <p>Example:</p> <pre><code>const silly: URL.Conversion&lt;boolean&gt; = (value) =&gt; Option.some(value === 'silly')\n\nconst funny: URL.Conversion&lt;number&gt; = (value) =&gt;\nvalue === 'funny' ? Option.some(42) : Option.none\n\nconst myRoute = route.useParamConversions({ silly, funny })\n\nconst funnyRoute = myRoute\n.get('/foo/:param(silly)/:other(funny)')\n.handler((request) =&gt; {\n// request.routeParams is { silly: boolean, funny: number }\n})\n</code></pre>"},{"location":"apiref/#router","title":"Router","text":"<pre><code>import { router } from 'typera-express'\n// or\nimport { router } from 'typera-koa'\n</code></pre> <p>The router is used to take a bunch of routes and turn them into a handler that you can then attach to your Express or Koa app.</p> <p>Available functions:</p> <ul> <li><code>router(...routes)</code></li> <li><code>r.add(...routes)</code></li> <li><code>r.handler()</code></li> </ul> <p>Use the <code>router()</code> function to create a router. Give it zero or more routes to add.</p> <p>The <code>.add()</code> method adds more routes to the router. Note that it returns a new <code>Router</code> instance instead of modifying the existing one.</p> <p>The <code>.handler()</code> method returns a handler that can be passed to <code>app.use()</code> for both Express and Koa.</p> <p>With Express, you can mount the handler to a sub-path like this:</p> <pre><code>import * as express from 'express'\n\nconst app = express()\n// ...\n\napp.use('/subpath', router.handler())\n</code></pre> <p>With Koa, you need to use koa-mount to mount your routes to a sub-path:</p> <pre><code>import * as Koa from 'koa'\nimport mount = require('koa-mount')\n\nconst app = new Koa()\n// ...\n\napp.use(mount('/subpath', router.handler()))\n</code></pre>"},{"location":"openapi/","title":"Generating OpenAPI definitions","text":"<p>See the documentation at typera-openapi.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Install typera with yarn or npm.</p> <p>For Express:</p> <pre><code>yarn add typera-express\n# or\nnpm install typera-express\n</code></pre> <p>For Koa:</p> <pre><code>yarn add typera-koa\n# or\nnpm install typera-koa\n</code></pre> <p>Here's an example of a typed route handler that updates a user's profile in the database:</p> <pre><code>// Change 'typera-express' to 'typera-koa' if you're using Koa\nimport { Parser, Response, Route, URL, route } from 'typera-express'\nimport * as t from 'io-ts'\n\ninterface User {\nid: number\nname: string\nage: number\n}\n\n// Decodes an object { name: string, age: number }\nconst userBody = t.type({ name: t.string, age: t.number })\n\nconst updateUser: Route&lt;\nResponse.Ok&lt;User&gt; | Response.NotFound | Response.BadRequest&lt;string&gt;\n&gt; = route\n.put('/user/:id(int)') // Capture id from the path\n.use(Parser.body(userBody)) // Use the userBody decoder for the request body\n.handler(async (request) =&gt; {\n// This imaginary function takes the user id and data, and updates the\n// user in the database. If the user does not exist, it returns null.\nconst user = await updateUserInDatabase(\nrequest.routeParams.id,\nrequest.body\n)\n\nif (user === null) {\nreturn Response.notFound()\n}\n\nreturn Response.ok({\nid: user.id,\nname: user.name,\nage: user.age,\n})\n})\n</code></pre> <p>Let's go through it in detail.</p> <pre><code>// Change 'typera-express' to 'typera-koa' if you're using Koa\nimport { Parser, Response, Route, URL, route } from 'typera-express'\n\ninterface User {\nid: number\nname: string\nage: number\n}\n\n// Decodes an object { name: string, age: number }\nconst userBody = t.type({ name: t.string, age: t.number })\n</code></pre> <p>We first import the stuff that is needed, and define an object type that is returned from the route handler. We also define an io-ts codec for decoding incoming user data.</p> <pre><code>const updateUser: Route&lt;\nResponse.Ok&lt;User&gt; | Response.NotFound | Response.BadRequest&lt;string&gt;\n&gt; = route /* ... */\n</code></pre> <p>Then we declare our route's possible responses: <code>200 OK</code> with <code>User</code> as a body, <code>404 Not Found</code>, or <code>400 Bad Request</code> with a <code>string</code> body.</p> <p>The types in the <code>Response</code> namespace correspond to HTTP status codes, and their type parameter denotes the type of the response body. All the standard statuses are covered, and you can also have custom ones like this: <code>Response.Response&lt;418, string&gt;</code></p> <p>You don't need to provide the response types because typera will infer them for you. But annotating helps you catch bugs if you accidentally change the result data of a route. By annotating your route with what you actually wanted to return, you let the compiler notice if reality doesn't match the expectations.</p> <pre><code>route\n.put('/user/:id(int)') // Capture id from the path\n.use(Parser.body(userBody)) // Use the userBody decoder for the request body\n.handler(async (request) =&gt; {\n/* ... */\n})\n</code></pre> <p>Here we tell that our route is going to handle <code>PUT</code> requests. The argument of <code>route.put()</code> is the path pattern. Parts of the path can be captured, like <code>:id(int)</code> above (more on that later).</p> <p>The <code>.use()</code> method adds a middleware to the route. The <code>userBody</code> io-ts codec was defined above, and passing it to the <code>Parser.body()</code> middleware instructs typera to parse the incoming request body with that codec.</p> <p>The <code>.handler()</code> method adds the actual route logic, and here is where the magic happens. The function passed to <code>.handler()</code> gets as an argument the <code>request</code> object, that will contain all path captures as well as all the results of the middleware you passed. And what's great is that the data is correctly typed!</p> <p>In our example, <code>request</code> will have the following inferred type:</p> <pre><code>interface MyRequest {\nrouteParams: {\n// These are the path captures, `:id(int)` in this case\nid: number\n}\nbody: {\n// This is the output of the userBody decoder\nname: string\nage: number\n}\n\n// With typera-express\nreq: express.Request\nres: express.Response\n\n// With typera-koa\n//ctx: koa.Context\n}\n</code></pre> <p>(In reality the type won't be exatly as above, but a bit more complex intersection type instead. In any case, it can be used as if it was like above, editor autocomplete will work correctly, etc.)</p> <p>The last part is the actual route logic:</p> <pre><code>route\n.put(/*...*/)\n.use(/*...*/)\n.handler(async (request) =&gt; {\n// This imaginary function takes the user id and data, and updates the\n// user in the database. If the user does not exist, it returns null.\nconst user = await updateUserInDatabase(\nrequest.routeParams.id,\nrequest.body\n)\n\nif (user === null) {\nreturn Response.notFound()\n}\n\nreturn Response.ok({\nid: user.id,\nname: user.name,\nage: user.age,\n})\n})\n</code></pre> <p>The above code returns either <code>200 OK</code> with the user data in the body, or <code>404 Not Found</code> without any body, depending on whether the user was found in the database or not.</p> <p>Note that the OK response body corresponds to the <code>User</code> type we defined earlier. We annotated the route handler to return a <code>User</code> body with the OK response.</p> <p>Let's assume we made a typo in our code and wrote <code>ic</code> instead of <code>id</code>:</p> <pre><code>return Response.ok({ ic: user.id, name: user.name, age: user.age })\n// OOPS! -------------^\n</code></pre> <p>The TypeScript compiler catches this and gives you an error. Likewise, if in the future someone changes the <code>updateUserFromDatabase</code> function and e.g. adds a new field to the user data that the function takes as the second argument, the code won't compile before they also fix the <code>userBody</code> decoder to match the new type.</p> <p>It's not required to use the response helpers like <code>Response.ok()</code> or <code>Response.notFound()</code>. You can also return plain objects: <code>return { status: 200, body: { ... }, headers: { ... } }</code></p> <p>Did you notice that the <code>updateUser</code> route handler also had a <code>Response.BadRequest&lt;string&gt;</code> as a possible response even though the route logic never returns such a response? This is because the validation of the request body can fail. The <code>Parser.body()</code> middleware produces a <code>400 Bad Request</code> response if the request body doesn't pass validation, and this response type is included as one of the possible response types of the route.</p> <p>There's one piece still missing: adding our route handlers to the app. Use the <code>router()</code> function to create a router from a bunch of routes, and the <code>.handler()</code> method of the router to get a handler that can be added to the app.</p> <p>Here's an example for Express:</p> <pre><code>import * as express from 'express'\nimport * as bodyParser from 'body-parser'\nimport { router } from 'typera-express'\n\nconst app = express()\n\n// body-parser is needed if you use Parser.body()\napp.use(bodyParser.json())\n\napp.use(router(updateUser /*, otherRoute, stillAnother */).handler())\n</code></pre> <p>And for Koa:</p> <pre><code>import * as Koa from 'koa'\nimport * as bodyParser from 'koa-bodyparser'\nimport { router } from 'typera-koa'\n\nconst app = new Koa()\n\n// koa-bodyparser is needed if you use Parser.body()\napp.use(bodyParser())\n\napp.use(router(updateUser /*, otherRoute, stillAnother */).handler())\n</code></pre>"},{"location":"upgrading/","title":"Upgrading to version 2","text":"<p>TypeScript 4.1 is required:</p> <pre><code>npm install --save-dev typescript@&gt;=4.1\n</code></pre> <p>If still using the function chaining syntax for routes, use the new syntax instead:</p> <pre><code>// OLD\nroute.get('/my/path')(middleware)(async request =&gt; { ... })\n\n// NEW\nroute\n.get('/my/path')\n.use(middleware)\n.handler(async request =&gt; { ... })\n</code></pre> <p>Change route paths to use <code>:param</code>-style captures:</p> <pre><code>// OLD\nroute.get('/category/', URL.int('id'), '/tag/', URL.str('tag'))\n\n// NEW\nroute.get('/category/:id(int)/tag/:tag')\n</code></pre> <p>If you had defined custom capturing functions, use <code>route.useParamConversions()</code> to use them in your paths.</p>"}]}